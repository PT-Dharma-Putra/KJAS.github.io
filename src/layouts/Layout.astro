---
import { ClientRouter } from "astro:transitions";
---

<!doctype html>
<html class="scroll-smooth overflow-x-hidden" lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/images/logo-kjas.jpg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <title>KJAS Furniture | Luxury Earthy Elegance</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Inter:wght@300;400;500;600&family=Material+Icons+Outlined&family=Great+Vibes&display=swap"
      rel="stylesheet"
    />
    <ClientRouter />
  </head>
  <body
    class="bg-background-light text-slate-800 font-sans selection:bg-primary/30 overflow-x-hidden"
  >
    <main id="main-content">
      <slot />
    </main>

    <style is:global>
      /* Base reveal states */
      .reveal {
        opacity: 0;
        transform: translateY(30px);
        transition: all 0.8s cubic-bezier(0.22, 1, 0.36, 1);
        will-change: transform, opacity;
      }

      .reveal.active {
        opacity: 1;
        transform: translateY(0);
      }

      /* Staggered entrance helpers */
      .stagger-1 {
        transition-delay: 0.1s;
      }
      .stagger-2 {
        transition-delay: 0.2s;
      }
      .stagger-3 {
        transition-delay: 0.3s;
      }
      .stagger-4 {
        transition-delay: 0.4s;
      }
    </style>

    <script shadow>
      // Scroll Reveal logic
      function initReveal() {
        const observerOptions = {
          root: null,
          rootMargin: "0px",
          threshold: 0.15,
        };

        const observer = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              entry.target.classList.add("active");
              // Once animated, we can stop observing it
              observer.unobserve(entry.target);
            }
          });
        }, observerOptions);

        document
          .querySelectorAll(".reveal")
          .forEach((el) => observer.observe(el));
      }

      // Watermark function inlined to avoid SSR issues
      function applyWatermark(images) {
        if (typeof images === "string") {
          images = document.querySelectorAll(images);
        } else if (images instanceof HTMLImageElement) {
          images = [images];
        }

        const logoSrc = "/images/logo-kjas.jpg";

        images.forEach(async (img) => {
          if (img.dataset.watermarked || img.closest(".watermark-wrapper"))
            return;

          try {
            if (!img.complete) {
              await new Promise((resolve) => {
                img.onload = resolve;
                img.onerror = resolve;
              });
            }

            const originalWidth = img.naturalWidth || img.width;
            const originalHeight = img.naturalHeight || img.height;

            if (originalWidth < 100 || originalHeight < 100) return;

            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = originalWidth;
            canvas.height = originalHeight;

            ctx.drawImage(img, 0, 0, originalWidth, originalHeight);

            const text = "PT KARTIKA JAYA ANANDA SEJAHTERA";
            ctx.save();
            ctx.translate(originalWidth / 2, originalHeight / 2);
            ctx.rotate(-Math.PI / 6);

            const fontSize = Math.max(20, Math.floor(originalWidth * 0.05));
            ctx.font = `bold ${fontSize}px sans-serif`;

            ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
            ctx.shadowBlur = 4;
            ctx.fillText(text, 0, 0);
            ctx.restore();

            const logo = new Image();
            logo.src = logoSrc;
            logo.crossOrigin = "Anonymous";

            await new Promise((resolve) => {
              logo.onload = resolve;
              logo.onerror = () => resolve();
            });

            if (logo.complete && logo.naturalWidth > 0) {
              const logoWidth = originalWidth * 0.15;
              const logoHeight =
                (logo.naturalHeight / logo.naturalWidth) * logoWidth;
              const padding = originalWidth * 0.02;

              ctx.globalAlpha = 0.8;
              ctx.drawImage(
                logo,
                originalWidth - logoWidth - padding,
                originalHeight - logoHeight - padding,
                logoWidth,
                logoHeight,
              );
              ctx.globalAlpha = 1.0;
            }

            const isPng = img.src.toLowerCase().split("?")[0].endsWith(".png");
            const watermarkedUrl = canvas.toDataURL(
              isPng ? "image/png" : "image/jpeg",
              isPng ? 1.0 : 0.9,
            );

            const wrapper = document.createElement("div");
            wrapper.classList.add("watermark-wrapper");
            wrapper.className = img.className;
            wrapper.style.position = "relative";
            wrapper.style.display =
              window.getComputedStyle(img).display === "block"
                ? "block"
                : "inline-block";
            wrapper.style.overflow = "hidden";

            const originalStyle = window.getComputedStyle(img);
            const fit = originalStyle.objectFit || "cover";
            const position = originalStyle.objectPosition || "center";

            wrapper.style.backgroundImage = `url("${img.src}")`;
            wrapper.style.backgroundSize =
              fit === "cover"
                ? "cover"
                : fit === "contain"
                  ? "contain"
                  : "100% 100%";
            wrapper.style.backgroundPosition = position;
            wrapper.style.backgroundRepeat = "no-repeat";

            const watermarkedImg = new Image();
            watermarkedImg.src = watermarkedUrl;
            watermarkedImg.style.display = "block";
            watermarkedImg.style.width = "100%";
            watermarkedImg.style.height = "100%";
            watermarkedImg.style.objectFit = fit;
            watermarkedImg.style.opacity = "0.01";
            watermarkedImg.style.cursor = "inherit";
            watermarkedImg.alt = img.alt;
            watermarkedImg.dataset.watermarked = "true";

            img.parentNode.insertBefore(wrapper, img);
            wrapper.appendChild(watermarkedImg);
            img.remove();
          } catch (e) {
            console.error("Error watermarking image:", e);
          }
        });
      }

      const runWatermark = () => {
        const images = document.querySelectorAll(
          "#main-content img:not([data-watermark-processed])",
        );
        images.forEach((img) => {
          // Mark as processed immediately to avoid double processing during async operations
          img.setAttribute("data-watermark-processed", "true");
          applyWatermark(img);
        });
      };

      const observeImages = () => {
        const target = document.getElementById("main-content");
        if (!target) return;

        const observer = new MutationObserver((mutations) => {
          let needsRun = false;
          mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
              if (node instanceof HTMLElement) {
                if (
                  node.tagName === "IMG" &&
                  !node.hasAttribute("data-watermark-processed")
                ) {
                  needsRun = true;
                } else if (
                  node.querySelectorAll("img:not([data-watermark-processed])")
                    .length > 0
                ) {
                  needsRun = true;
                }
              }
            });
          });
          if (needsRun) runWatermark();
        });

        observer.observe(target, { childList: true, subtree: true });
      };

      const init = () => {
        initReveal();
        runWatermark();
        observeImages();
        // Fallback for any late-loading dynamic content
        setTimeout(runWatermark, 1000);
        setTimeout(runWatermark, 3000);
      };

      window.addEventListener("load", init);
      document.addEventListener("astro:page-load", init);
    </script>
  </body>
</html>
